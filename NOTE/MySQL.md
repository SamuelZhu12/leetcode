# MySQL理论基础

## 1.简介

(1) MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。
(2) MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。
(3) Mysql是开源的，所以你不需要支付额外的费用。
(4) Mysl支持大型的数据库，可以处理拥有上千万条记录的大型数据库。
(5) MySQL使用标准的SQL数据语言形式。
(6) Mysql可以允许于多个系统上，并且支持多种语言，这些编程语言包括C、C++、Python、Java、Ped、PHP、Eifel、Ruby和TCL等
(7) MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。
(8) Mysql是可以定制的，采用了GPL协议，你可以修改源码来开发自己的Mysql系统

## 2.架构

<img src="C:\Users\56268\Desktop\note\MySQL.assets\a762bd56e189af35e0cfd896a595efb1.png" alt="img" style="zoom:80%;" />

### 2.1 连接层
最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限

### 2.2 服务层
第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能

1. **SQL Interface **

​	SQL接口。接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface

2. **Parser（解析器）**

   1. SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本。
   2. 在 MySQL中我们习惯将所有 Client 端发送给 Server 端的命令都称为 Query，在 MySQL Server 里面，连接线程接收到客户端的一个 Query 后，会直接将该 Query 传递给专门负责将各种 Query 进行分类然后转发给各个对应的处理模块。
   3. 解析器将SQL语句进行语义和语法的分析，分解成数据结构，然后按照不同的操作类型进行分类，然后做出针对性的转发到后续步骤，SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的。

3. **Optimizer(优化器) **
    SQL语句在查询之前会使用查询优化器对查询进行优化。就是优化客户端发送过来的 sql 语句 ，根据客户端请求的 query 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 query 语句的结果

4. **Cache和Buffer**
    1. 主要功能是将客户端提交 给MySQL 的 Select 类 query 请求的返回结果集 cache 到内存中，与该 query 的一个 hash 值做一个对应。该 Query 所取数据的基表发生任何数据的变化之后， MySQL 会自动使该 query 的Cache 失效。在读写比例非常高的应用系统中，Query Cache 对性能的提高是非常显著的。当然它对内存的消耗也是非常大的。
    2. 如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等

###  2.3 引擎层
存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过APl与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。


### 2.4 存储层
数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互

## 3. 索引

### 3.1 定义
1. 定义：索引(Index)是帮助MySQL高效获取数据的数据结构
2. 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据实现高级查找算法。**这种数据结构，就是索引**
3. 排好序的快速查找数据结构"，即索引 = 排序 + 查找
4. 一般来说索引本身占用内存空间也很大，不可能全部存储在内存中，因此索引往往以文件形式存储在硬盘上
5. 我们平时所说的索引，一般是指B树(多路搜索树，并不一定是二叉树)结构组织的索引

### 3.2 B树（B-树）

在谈论B树之前，先看看红黑树

![img](C:\Users\56268\Desktop\note\MySQL.assets\1.png)

上图展示了一种可能的索引方式，左表是数据表，col1是数据的物理地址（逻辑上地址相邻不代表磁盘上物理相邻），而为了加快col2的索引键值查找，可以维护一个右边所示的平衡二叉树（AVL），每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样可以利用二叉寻找在$O(log_2n)$的复杂度内获得相应数据。

但实际的数据库系统中几乎没有使用这种二叉查找树或者进化品种**红黑树**实现的。

<img src="C:\Users\56268\Desktop\note\MySQL.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NTQ1Mzg=,size_16,color_FFFFFF,t_70-16588514685819.png" alt="在这里插入图片描述" style="zoom:67%;" />

**红黑规则**：

1. 节点不是黑色，就是红色（非黑即红）
2. 根节点为黑色
3. 叶节点为黑色（叶节点是指末梢的空节点 `Nil`或`Null`）
4. 一个节点为红色，则其两个子节点必须是黑色的（根到叶子的所有路径，不可能存在两个连续的红色节点）
5. 每个节点到叶子节点的所有路径，都包含相同数目的黑色节点（相同的黑色高度）

**与AVL对比**：

1. AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过旋转操作保持平衡
2. 在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣
3. 红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，整体性能优于AVL
4. 红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决红黑树的红黑规则，保证最坏的情况下，也能在$O(log_2n)$时间内完成查找操作。



从二叉搜索树 → AVL，严格控制左右子树高度差，避免二叉搜索树退化成链表（时间复杂度从$O(log_2n)$ 退化成$O(n)$）。

从AVL → 红黑树，牺牲严格的平衡要求，以换取新增/删除节点时少量的旋转操作，平均性能优于AVL；通过红黑规则，保证在最坏的情况下，也能拥有$O(log_2n)$的时间复杂度。

而红黑树面对超大的数据量时无法避免较大的树高，因此实际的数据库系统中多用B/B+树来作为索引。

**B树的定义**：

![在这里插入图片描述](C:\Users\56268\Desktop\note\MySQL.assets\watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmF2YVB1Yi1yb2RlcnQ=,size_19,color_FFFFFF,t_70,g_se,x_16.png)

- 每个节点最多有m-1个关键字（可以存有的键值对）。


- 根节点最少可以只有1个关键字。

- 非根节点至少有m/2个关键字。

- 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。

- 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。

- 每个节点都存有索引和数据，也就是对应的key和value。 

相比AVL，B树的每个节点可以存储多个数据，而且每个节点不止有两个子节点，最多可以有上千个子节点。同时，B树中每个节点都存放着索引和数据，数据遍布整个结构，搜索可能在非叶子节点结束，因此最好的情况时间复杂度可能是$O(1)$

### 3.3 B+树

![img](C:\Users\56268\Desktop\note\MySQL.assets\watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASmF2YVB1Yi1yb2RlcnQ=,size_19,color_FFFFFF,t_70,g_se,x_16-165885172863011.png)

B+树是B树的一种变种，其区别在于：

- **叶子节点保存了完整的索引和数据，而非叶子节点只保存索引值**，因此它的查询时间固定为 log(n).
- 叶子节点中有指向下一个叶子节点的指针，**叶子节点类似于一个单链表**
- 正因为叶子节点保存了完整的数据以及有指针作为连接，B+树可以增加了区间访问性，提高了范围查询，而B树的范围查询相对较差
- B+树更适合外部存储。因为它的非叶子节点不存储数据，只保存索引。

**B+树比B树的优势**：

- b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；

- b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；

- 对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历。例如上图中如果要查询key为从25到71的所有数据记录，当找到25后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。

对比来讲，红黑树更适合数据量偏小的场景，适用于内存查询，树相对较高，自平衡但平衡性不严格，需要O(1)的自旋次数保证平衡，是一种自平衡二叉查找树。B树适合数据量较大的外部存储，由于磁盘IO的瓶颈，尽可能少的IO次数和更高的IO利用率能够在磁盘等辅存设备的领域发挥作用，B树高度远小于红黑树，磁盘IO数量大大减少，是一种多路平衡查找树。

## 4.事务

MySQL 事务都是指在 InnoDB 引擎下，MyISAM 引擎是不支持事务的。

数据库事务指的是一组数据操作，事务内的操作要么就是全部成功，要么就是全部失败，什么都不做，其实不是没做，是可能做了一部分但是只要有一步失败，就要回滚所有操作，有点一不做二不休的意思。

## 4.1 事务的特性（ACID）

事务具有原子性、一致性、隔离性和持久性四种特性，简称ACID。

- **原子性**：原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做,如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。

    MySQL的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种事务日志：redo log(重做日志)和undo log(回滚日志)。其中redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础。

    **实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。**InnoDB实现回滚，靠的是undo log：当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。
    
- **一致性**：数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。例如对银行转帐事务，不管事务成功还是失败，应该保证事务结束后ACCOUNTS表中Tom和Jack的存款和不变。

- **持久性**：持久性是指事务一旦提交，它对数据库的更改应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

  
    InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：**当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中**
    
    Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。redo log被引入来解决持久性问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。
    
- **隔离性**：
    (1) 隔离性是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰
    (2) 一个事务写操作对另一个事务写操作的影响：锁机制保证隔离性
    (3) 一个事务写操作对另一个事务读操作的影响：MVCC保证隔离性

​		**事务隔离级别要解决的问题**：

​		  1.**脏读**

​			脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在			的数据。读到了并一定最终存在的数据，这就是脏读。

​		 2.**可重复读**

​			可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。通常针对数据**更新			(UPDATE)**操作。

​		 3.**不可重复读**

​			对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比			如其他事务改了这批数据并提交了。通常针对数据**更新（UPDATE）**操作。

​		 4.**幻读**

​			幻读是针对数据**插入（INSERT）**操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更			改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起			作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。


# 参考：

[红黑树详解]: https://blog.csdn.net/u014454538/article/details/120120216

[MySQL索引背后的数据结构及算法原理]: https://blog.codinglabs.org/articles/theory-of-mysql-index.html

[红黑树和b树的区别在哪?]: https://www.zhihu.com/question/266138161/answer/2501040270

[数据结构之B树/B+树]:https://www.bilibili.com/read/cv14452970
[B树和B+树的区别]: https://blog.csdn.net/qq_40374604/article/details/120284492

[MySQL事务隔离级别和实现原理（看这一篇文章就够了！）]: https://zhuanlan.zhihu.com/p/117476959/

